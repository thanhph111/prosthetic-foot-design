"""Main script for genetic algorithm and plotting.
You should not modify this.
"""

import os
import random
import subprocess
# import matplotlib
# import matplotlib.pyplot as plt
# from pylab import plot, show, ion
from inputprocess import *
import timeit
import concurrent.futures

domain = create_domains_list()
chromosome_size = len(domain)
chromosomes = []


class Chromosome():
    """Creating chromosomes for a generation's population."""
    def __init__(self):
        self.value = []
        for index in range(chromosome_size):
            self.value.append(
                random.uniform(domain[index][0], domain[index][1]))
        self.fitness = -1
        self.evaluate = -1


def init_chromosomes():
    global chromosomes
    chromosomes = [Chromosome() for _ in range(POPULATION_SIZE)]


def call(value):
    output = subprocess.check_output('abaqus cae noGUI=kernel.py -- %s' %
                                     (value),
                                     shell=True,
                                     universal_newlines=True)
    return float(output)


def fitness():
    global chromosomes
    max_fitness = 0.0

    with concurrent.futures.ProcessPoolExecutor() as executor:
        chromosomes_value_list = [
            chromosome.value for chromosome in chromosomes
        ]
        results_list = executor.map(call, chromosomes_value_list)
        for index, result in enumerate(results_list):
            chromosomes[index].fitness = result
            if max_fitness < result:
                max_fitness = result

    for chromosome in chromosomes:
        chromosome.evaluate = chromosome.fitness / max_fitness * 100
    chromosomes = sorted(chromosomes,
                         key=lambda chromosome: chromosome.evaluate,
                         reverse=True)


# def fitness():
#     global chromosomes
#     max_fitness = 0.0
#
#     for chromosome in chromosomes:
#         chromosome.fitness = call(chromosome.value)
#         if max_fitness < chromosome.fitness:
#             max_fitness = chromosome.fitness
#
#     for chromosome in chromosomes:
#         chromosome.evaluate = chromosome.fitness / max_fitness * 100
#     chromosomes = sorted(chromosomes,
#                          key=lambda chromosome: chromosome.evaluate,
#                          reverse=True)


def selection():
    global chromosomes
    chromosomes = chromosomes[:int(SELECTION_RATE * len(chromosomes))]


def crossover():
    global chromosomes
    offspring = []
    for _ in range(POPULATION_SIZE - len(chromosomes)):
        child = Chromosome()
        [parent_1, parent_2] = random.choices(
            population=chromosomes,
            weights=[chromosome.evaluate for chromosome in chromosomes],
            k=2)
        genes_of_parent_1 = random.sample(
            range(chromosome_size),
            int(chromosome_size * (parent_1.evaluate /
                                   (parent_1.evaluate + parent_2.evaluate))))
        for i in range(chromosome_size):
            if i in genes_of_parent_1:
                child.value[i] = parent_1.value[i]
            else:
                child.value[i] = parent_2.value[i]
        offspring.append(child)
    chromosomes.extend(offspring)


def mutation():
    mutation_index_list = random.sample(range(POPULATION_SIZE),
                                        int(MUTATION_RATE * POPULATION_SIZE))
    for index in mutation_index_list:
        chromosomes[index].value = [
            random.uniform(domain[i][0], domain[i][1])
            for i in range(chromosome_size)
        ]


def genetic_algorithm():
    global chromosomes
    chromosomes = []
    generation = 0
    max = 0
    generation_list = []
    max_list = []
    value_list = []
    init_chromosomes()
    fitness()
    while generation < GENERATION_SIZE:
        if max < chromosomes[0].fitness:
            max = chromosomes[0].fitness
            max_gene = generation
        max_list.append(max)
        print(max)
        value_list.append(chromosomes[0].fitness)
        generation_list.append(generation)

        selection()
        crossover()
        mutation()
        fitness()

        generation += 1


if __name__ == '__main__':
    start = timeit.default_timer()
    genetic_algorithm()
    stop = timeit.default_timer()
    print('%.2f' % (stop - start))
